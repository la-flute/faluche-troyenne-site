'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _enzyme = require('enzyme');

var _enzymeToJson = require('enzyme-to-json');

var _enzymeToJson2 = _interopRequireDefault(_enzymeToJson);

var _jestInCase = require('jest-in-case');

var _jestInCase2 = _interopRequireDefault(_jestInCase);

var _Async = require('../Async');

var _Async2 = _interopRequireDefault(_Async);

var _constants = require('./constants');

var _components = require('../components');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Option = _components.components.Option;


test('defaults - snapshot', function () {
  var tree = (0, _enzyme.mount)(_react2.default.createElement(_Async2.default, null));
  expect((0, _enzymeToJson2.default)(tree)).toMatchSnapshot();
});

/**
 * loadOptions with promise is not resolved and it renders loading options
 * confirmed by logging in component that loadOptions is resolved and options are available
 * but still loading options is rendered
 */
(0, _jestInCase2.default)('load option prop with defaultOptions true', function (_ref) {
  var props = _ref.props,
      expectOptionLength = _ref.expectOptionLength;

  var asyncSelectWrapper = (0, _enzyme.mount)(_react2.default.createElement(_Async2.default, _extends({ menuIsOpen: true }, props)));
  expect(asyncSelectWrapper.find(Option).length).toBe(expectOptionLength);
}, {
  'with callback  > should resolve options': {
    props: {
      defaultOptions: true,
      loadOptions: function loadOptions(inputValue, callBack) {
        return callBack([_constants.OPTIONS[0]]);
      }
    },
    expectOptionLength: 1
  },
  'with promise  > should resolve options': {
    skip: true,
    props: {
      defaultOptions: true,
      loadOptions: function loadOptions() {
        return Promise.resolve([_constants.OPTIONS[0]]);
      }
    },
    expectOptionLength: 1
  }
});

/**
 * loadOptions with promise is not resolved and it renders loading options
 * confirmed by logging in component that loadOptions is resolved and options are available
 * but still loading options is rendered
 */
(0, _jestInCase2.default)('load options props with no default options', function (_ref2) {
  var props = _ref2.props,
      expectloadOptionsLength = _ref2.expectloadOptionsLength;

  var asyncSelectWrapper = (0, _enzyme.mount)(_react2.default.createElement(_Async2.default, _extends({ className: 'react-select' }, props)));
  var inputValueWrapper = asyncSelectWrapper.find('div.react-select__input input');
  asyncSelectWrapper.setProps({ inputValue: 'a' });
  inputValueWrapper.simulate('change', { currentTarget: { value: 'a' } });
  expect(asyncSelectWrapper.find(Option).length).toBe(expectloadOptionsLength);
}, {
  'with callback > should resolve the options': {
    props: {
      loadOptions: function loadOptions(inputValue, callBack) {
        return callBack(_constants.OPTIONS);
      }
    },
    expectloadOptionsLength: 17
  },
  'with promise > should resolve the options': {
    skip: true,
    props: {
      loadOptions: function loadOptions() {
        return Promise.resolve(_constants.OPTIONS);
      }
    },
    expectloadOptionsLength: 17
  }
});

/**
 * Need to update porps to trigger on change in input
 * when updating props renders the component therefore options cache is lost thus loadOptions is called again
 */
test.skip('to not call loadOptions again for same value when cacheOptions is true', function () {
  var loadOptionsSpy = jest.fn();
  var asyncSelectWrapper = (0, _enzyme.mount)(_react2.default.createElement(_Async2.default, { className: 'react-select', loadOptions: loadOptionsSpy, cacheOptions: true }));
  var inputValueWrapper = asyncSelectWrapper.find('div.react-select__input input');

  asyncSelectWrapper.setProps({ inputValue: 'a' });
  inputValueWrapper.simulate('change', { currentTarget: { value: 'a' } });
  expect(loadOptionsSpy).toHaveBeenCalledTimes(1);

  asyncSelectWrapper.setProps({ inputValue: 'b' });
  inputValueWrapper.simulate('change', {
    target: { value: 'b' },
    currentTarget: { value: 'b' }
  });
  expect(loadOptionsSpy).toHaveBeenCalledTimes(2);

  asyncSelectWrapper.setProps({ inputValue: 'b' });
  inputValueWrapper.simulate('change', { currentTarget: { value: 'b' } });
  expect(loadOptionsSpy).toHaveBeenCalledTimes(2);
});

test('to create new cache for each instance', function () {
  var asyncSelectWrapper = (0, _enzyme.mount)(_react2.default.createElement(_Async2.default, { cacheOptions: true }));
  var instanceOne = asyncSelectWrapper.instance();

  var asyncSelectTwoWrapper = (0, _enzyme.mount)(_react2.default.createElement(_Async2.default, { cacheOptions: true }));
  var instanceTwo = asyncSelectTwoWrapper.instance();

  expect(instanceOne.optionsCache).not.toBe(instanceTwo.optionsCache);
});

test('in case of callbacks display the most recently-requested loaded options (if results are returned out of order)', function () {
  var callbacks = [];
  var loadOptions = function loadOptions(inputValue, callback) {
    callbacks.push(callback);
  };
  var asyncSelectWrapper = (0, _enzyme.mount)(_react2.default.createElement(_Async2.default, { className: 'react-select', loadOptions: loadOptions }));
  var inputValueWrapper = asyncSelectWrapper.find('div.react-select__input input');
  asyncSelectWrapper.setProps({ inputValue: 'foo' });
  inputValueWrapper.simulate('change', { currentTarget: { value: 'foo' } });
  asyncSelectWrapper.setProps({ inputValue: 'bar' });
  inputValueWrapper.simulate('change', { currentTarget: { value: 'bar' } });
  expect(asyncSelectWrapper.find(Option).exists()).toBeFalsy();
  callbacks[1]([{ value: 'bar', label: 'bar' }]);
  callbacks[0]([{ value: 'foo', label: 'foo' }]);
  asyncSelectWrapper.update();
  expect(asyncSelectWrapper.find(Option).text()).toBe('bar');
});

/**
 * This throws a jsdom exception
 */
test.skip('in case of callbacks should handle an error by setting options to an empty array', function () {
  var loadOptions = function loadOptions(inputValue, callback) {
    callback(new Error('error'));
  };
  var asyncSelectWrapper = (0, _enzyme.mount)(_react2.default.createElement(_Async2.default, {
    className: 'react-select',
    loadOptions: loadOptions,
    options: _constants.OPTIONS
  }));
  var inputValueWrapper = asyncSelectWrapper.find('div.react-select__input input');
  asyncSelectWrapper.setProps({ inputValue: 'foo' });
  inputValueWrapper.simulate('change', { currentTarget: { value: 'foo' } });
  asyncSelectWrapper.update();
  expect(asyncSelectWrapper.find(Option).length).toBe(1);
});